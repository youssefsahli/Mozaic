[
  {
    "id": "tutorial-hub",
    "title": "Tutorial Hub",
    "category": "Tutorial",
    "content": "# Tutorial Hub\nUse this hub as the recommended learning path for Mozaic.\n\n## Recommended Order\n1. Tutorial: First Playable ROM\n2. Tutorial: Multi-File Workflow\n3. Tutorial: Team Conventions\n\n## Quick Links\n- docs/TUTORIAL.md\n- docs/TUTORIAL_MULTIFILE.md\n- docs/TUTORIAL_TEAM_CONVENTIONS.md\n\n## What Each Tutorial Covers\n- First Playable ROM: setup, pixel + script basics, run/debug/save\n- Multi-File Workflow: file tree structure, imports, per-file editing flow\n- Team Conventions: naming, schema allocation policy, review checklist\n\n## Suggested Team Onboarding\n- Day 1: complete First Playable ROM\n- Day 2: complete Multi-File Workflow\n- Day 3: apply Team Conventions on a small feature PR"
  },
  {
    "id": "api-spec-live",
    "title": "API Spec (Async)",
    "category": "API",
    "content": "# API Spec (Async)\nThis chapter loads the autogenerated API specification asynchronously when opened.\n\n## Source\n- docs/api-spec.json\n\n## Behavior\n- Fetches fresh JSON on open\n- Renders counts and module export preview\n- Useful while reading docs without leaving the editor"
  },
  {
    "id": "tutorial-first-rom",
    "title": "Tutorial: First Playable ROM",
    "category": "Tutorial",
    "content": "# First Playable ROM\nFollow this chapter to create a tiny playable scene end-to-end.\n\n## Setup\n- npm install\n- npm run dev\n- Open the local app URL\n\n## Step 1: Create Asset\n- Click New and create a blank ROM\n- Open Pixel tab and paint a character and a level region\n- Use distinct colors for trigger targeting\n\n## Step 2: Script Basics\nAdd Schema, one Entity, and one Events collision rule.\n\n```\nSchema:\n  - $Score: { addr: 64, type: Int16 }\nEntity.Hero:\n  Input:\n    - Key_Space -> Action.Jump\nEvents:\n  Collision(Hero:#Feet, Level:#FFFF00):\n    - State.$Score = 1\n```\n\n## Step 3: Run and Debug\n- Click Run\n- Enable Debug collision overlays\n- Use Alt+Click near overlay lines to inspect baked layers\n\n## Step 4: Save\n- Click Save to export PNG\n- Reload later with ROM and keep iterating\n\n## Full Walkthrough\nSee docs/TUTORIAL.md for the full hands-on tutorial."
  },
  {
    "id": "tutorial-multifile-workflow",
    "title": "Tutorial: Multi-File Workflow",
    "category": "Tutorial",
    "content": "# Multi-File Workflow\nBuild organized projects with separate scripts and image assets.\n\n## Step 1: Structure\n- Create folders: assets and scripts\n- Add image files under assets\n- Add main.msc plus feature modules under scripts\n\n## Step 2: Compose Scripts\nUse imports from main.msc to compose feature modules.\n\n```\nImport: \"movement\"\nImport: \"combat\"\n```\n\n## Step 3: Keep Schema Addresses Unique\nPlan variable addresses so modules do not overlap byte ranges.\n\n## Step 4: Switch Files\n- Script nodes open Script tab\n- Image nodes open Pixel tab\n- Save-before-switch flow preserves per-file edits\n\n## Step 5: Validate\n- Click Run\n- Fix missing import path errors\n- Confirm each image file edits independently\n\n## Full Walkthrough\nSee docs/TUTORIAL_MULTIFILE.md for full details and project layout examples."
  },
  {
    "id": "tutorial-team-conventions",
    "title": "Tutorial: Team Conventions",
    "category": "Tutorial",
    "content": "# Team Conventions\nUse this chapter to keep multi-contributor projects consistent.\n\n## Naming Rules\n- lowercase file names with underscores\n- PascalCase entities\n- Action.VerbNoun action names\n\n## Folder Policy\n- assets/ for images\n- scripts/ for MSC modules\n- keep modules responsibility-focused\n\n## Schema Policy\n- reserve non-overlapping byte ranges\n- document address allocations centrally\n- update schema map before adding variables\n\n## Imports and Boundaries\n- keep main.msc as composition root\n- avoid cyclic imports\n- prefer one-way module dependencies\n\n## Review Checklist\n- naming and folder conventions respected\n- schema addresses conflict-free\n- imports resolve cleanly\n- docs index updated when conventions change\n\n## Full Guide\nSee docs/TUTORIAL_TEAM_CONVENTIONS.md for complete team workflow guidance."
  },
  {
    "id": "getting-started",
    "title": "Getting Started",
    "category": "Project",
    "content": "# Quick Start\n- npm install\n- npm run dev\n- npm run build\n- npm test\n\n## First Session\n- Click New to create a blank ROM\n- Open Pixel tab and draw a scene\n- Open Script tab and write MSC rules\n- Click Run to restart with latest assets\n- Click Save to export current ROM as PNG\n\n## Startup Sources\nYou can boot an asset using ?src=<url> or configure game.autoLoadSrc in mozaic.config.json."
  },
  {
    "id": "arch-overview",
    "title": "Architecture Overview",
    "category": "Architecture",
    "content": "# Runtime Model\nMozaic uses a deterministic 60 FPS loop built around immutable frame updates and a compact byte-addressed state buffer.\n\n## Core Stages\n- Load ROM + sidecar script\n- Bake static data caches from pixels\n- Tick pure logic at 60 FPS\n- Render state through WebGL\n\n## Data Regions\n- Header: 0..63\n- Globals: 64..511\n- Entity pool: 512..12287\n- Audio / FX: 12288..16383"
  },
  {
    "id": "arch-bake",
    "title": "Bake Pipeline",
    "category": "Architecture",
    "content": "# One-Time Bake\nBake runs on asset load and after editor-changing operations.\n\n## Bake Steps\n- Parse MSC script into an AST\n- Extract collision geometry from alpha channel\n- Simplify polygons with RDP\n- Extract path splines and control points\n- Cache audio sequencer grids\n\n## Why It Matters\nHeavy pixel analysis is moved out of the runtime loop so the frame tick remains low-allocation and predictable."
  },
  {
    "id": "arch-runtime",
    "title": "Runtime Tick",
    "category": "Architecture",
    "content": "# Per-Frame Pipeline\n- Sample input actions\n- Run physics broad + narrow checks\n- Evaluate script rules against state\n- Produce next state buffer\n- Render and advance frame counters\n\n## Logic Signature\n```\n(state, input, baked, script) => nextState\n```\n\n## Performance Notes\nPooling and fixed buffer layouts reduce GC churn during active gameplay."
  },
  {
    "id": "msc-syntax",
    "title": "MSC Script Syntax",
    "category": "Scripting",
    "content": "# MSC Basics\nMSC is a declarative, YAML-like DSL for entities, schema declarations, and event rules.\n\n## Top-Level Keys\n- Source\n- Import\n- Schema\n- Entity.<Name>\n- Events\n\n## Minimal Example\n```\nSource: \"level.mzk\"\nSchema:\n  - $Score: { addr: 64, type: Int16 }\nEntity.Hero:\n  Input:\n    - Key_Space -> Action.Jump\nEvents:\n  Collision(Hero:#Feet, Level:#FFFF00):\n    - State.$Score = 1\n```"
  },
  {
    "id": "msc-schema-events",
    "title": "Schema and Events",
    "category": "Scripting",
    "content": "# Schema Planning\nDeclare each state variable with byte offset and type.\n\n## Supported Types\n- Int8\n- Int16\n- Int24\n\n## Event Triggers\n- Collision(EntityA:#Color, EntityB:#Color)\n- Input-driven actions via Entity input mappings\n\n## Action Pattern\nWrite deterministic state updates in event action lines, for example State.$Health = 0."
  },
  {
    "id": "editor-workflow",
    "title": "Editor Workflow",
    "category": "Editor",
    "content": "# Tabs\n- Script: MSC editing with syntax highlights\n- Pixel: ROM painting and palette tools\n- Debug: Grid and baked overlay controls\n- Docs: Searchable in-editor documentation\n\n## Typical Loop\n- Edit art in Pixel tab\n- Adjust script logic in Script tab\n- Use Debug overlays to inspect bake results\n- Run to validate behavior"
  },
  {
    "id": "editor-shortcuts",
    "title": "Keyboard Shortcuts",
    "category": "Editor",
    "content": "# Pixel Shortcuts\n- B: Pencil\n- E: Eraser\n- G: Fill\n- I: Pipette\n- M: Select\n- Ctrl+Z: Undo\n- Ctrl+Y: Redo\n\n## Interaction Shortcuts\n- Alt+Click near overlay: pick nearest debug layer\n- Right click on canvas: pick color\n- Mouse wheel: zoom"
  },
  {
    "id": "engine-audio-physics",
    "title": "Audio and Physics",
    "category": "Engine",
    "content": "# Audio Sequencer\nAudio notes are read from pixel-grid patterns (16x16 or 32x32) and scheduled using Web Audio timing windows.\n\n## Collision Flow\n- Broad phase: AABB overlap\n- Narrow phase: polygon and color-region tests\n\n## Runtime Character\nCollision geometry and path data are baked once and reused across frames."
  },
  {
    "id": "chapter-components",
    "title": "Components Chapter",
    "category": "Components",
    "content": "# Components Chapter\nThis chapter describes the Mozaic building blocks and their responsibilities.\n\n## Editor Components\n- PixelEditor: drawing, selection, color tools, and status integration\n- FileTreeView: project tree rendering, selection, rename/create/delete workflows\n- InputHandler: key, pointer, and tool intent mapping\n- GridOverlay: inline/custom grid visualization and debug alignment\n- Palette + PalettePresets: swatches, presets, and replacement utilities\n- Layers + Tools: active layer/tool state and tool-specific behavior\n\n## Engine Components\n- Loader: ROM/script loading and sidecar resolution\n- Baker: collision/path/audio cache extraction from image data\n- Evaluator: MSC AST evaluation and state transitions\n- Loop: deterministic frame pipeline orchestration\n- Renderer: state-to-canvas WebGL presentation\n- Physics: overlap checks and collision helpers\n- Audio: sequencer scheduling and gain-node pooling\n- Memory: typed reads/writes over fixed state regions\n- Pathfinding: path tracing and spline generation\n- Pool: ring buffers and object/free-list pools\n\n## Parser Components\n- Lexer: tokenizes MSC source text\n- AST builder: structural parse of script documents\n- MSC parser: high-level parse helpers and composition\n\n## Integration Components\n- Runtime bootstrap (src/index.ts): UI wiring, tab orchestration, docs, file/project plumbing"
  },
  {
    "id": "components-list",
    "title": "Components List",
    "category": "Components",
    "content": "# Components List\nA quick reference of notable modules and classes.\n\n## Editor\n- editor/camera.ts: canvas viewport and camera transforms\n- editor/file-system.ts: in-memory project tree, file factories, persistence helpers\n- editor/file-tree-view.ts: hierarchical file browser UI\n- editor/grid-overlay.ts: grid render and configuration behavior\n- editor/history.ts: undo/redo stacks and snapshots\n- editor/input-handler.ts: pointer + keyboard translation for tools\n- editor/layers.ts: layer models and operations\n- editor/palette-presets.ts: reusable palette definitions\n- editor/palette.ts: palette state and color operations\n- editor/pixel-editor.ts: high-level editor orchestrator\n- editor/tools.ts: tool implementations and shared tool helpers\n- editor/types.ts: shared editor type declarations\n\n## Engine\n- engine/audio.ts: sequencer logic and scheduling primitives\n- engine/baker.ts: bake-time extraction and cache generation\n- engine/components.ts: engine-side component records/types\n- engine/evaluator.ts: applies script rules to state buffers\n- engine/import-resolver.ts: script import resolution flow\n- engine/input.ts: action maps and device polling\n- engine/loader.ts: asset loading and format handling\n- engine/loop.ts: main frame loop and step sequencing\n- engine/memory.ts: fixed-layout state access helpers\n- engine/pathfinding.ts: path extraction and interpolation utilities\n- engine/physics.ts: broad/narrow collision helpers\n- engine/pool.ts: pooling primitives for low-allocation runtime\n- engine/renderer.ts: WebGL draw pipeline\n\n## Parser\n- parser/ast.ts: AST node definitions and constructors\n- parser/lexer.ts: lexical analysis and token streams\n- parser/msc.ts: document parse entrypoints\n\n## Entry and Tests\n- src/index.ts: application bootstrap and UI/runtime integration\n- src/__tests__/*.test.ts: behavior coverage for parser, engine, editor, and integration paths"
  },
  {
    "id": "entity-state-reference",
    "title": "Entity State Reference",
    "category": "Reference",
    "content": "# Entity State Reference\nState management in Mozaic allows entities to change their appearance and behavior dynamically based on conditions.\n\n## Defining States\nStates are defined under the `States:` key in an entity definition.\n\n## How States Work\n- Evaluation Order: Top to bottom\n- First Match Wins\n- Fallback: Uses base definition if no condition is met\n\n## Writing Conditions\n- Operators: ==, !=, >, <, >=, <=\n- Variables: Local ($vx, $vy) or Global (State.$var)\n\n## Overriding Properties\n- Visual: Changes sprite\n- Components: Updates properties (Gravity, Speed)\n\n## Full Reference\nSee docs/ENTITY_STATES.md for complete details and examples."
  }
]
